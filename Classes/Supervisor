import numpy as np
import numpy.linalg as la
import math
import Vechicle from Classes.vehicle 
import LQR from Tools.lqr
"""
Continous dynamics car, contains cost function for elipse track
"""

class Supervisor(): 
	T = 200.0 
	dt = 1


	def __init__():
		Q = np.eye(4)
		R = np.eye(2)
		self.car = Vechicle()
		self.lqr = LQR()
		[ref_states,ref_controls] = self.genElipse()
		[A_mats,B_mats] = linearizeTraj(ref_x,ref_u)
		self.Ks = self.lqr.ltv_lqr(As,Bs,Q,R,self.T)




	def genElipse(self):
		a = 1000
		b = 500
		ref_states = np.zeros([4,T])
		ref_controls = np.zeros([2,T])

		#Set velocity to angle/T 
		ref_states[3,:] = 2*math.pi/self.T


		for i in range(int(self.T)):
			frac = i/self.T 
			ref_states[0,i] = a*np.cos(frac*2*math.pi)
			ref_states[1,i] = b*np.cos(frac*2*math.pi)

			tan = np.array([-a*np.sin(frac),b*np.cos(frac)])
			tan = unit/la.norm(unit)
			unit_x = np.array([0,1])
			cos_a = np.dot(tan,unit_x)

			ref_states[2,i] = np.acos(cos_a)

		for i in range(1,int(self.T)):
			ref_controls = ref_states[2,i] - ref_states[2,i-1] 


		return ref_states,ref_controls


	def linearizeTraj(self,ref_x,ref_u): 

		A_mats = [] 
		B_mats = [] 

		for i in range(self.T):
			[A,B,c] = linearize_dynamics(car.dynamics,ref_x[i,:], ref_u[i,:], self.dt):
			A_mats.append(A)
			B_mats.append(B)


if __name__ == '__main__':
	IPython.embed()
	sup = Supervisor()

	